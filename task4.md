D. Распределённая система

Ограничение времени	1 секунда
Ограничение памяти	64 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

python 3.7.3

Рассмотрим распределённую вычислительную систему, состоящую из n вычислительных узлов (серверов), между которыми установлены каналы связи, образующие дерево (т.е. сеть без циклов, где между любой парой узлов существует единственный путь). Эта структура определяет топологию обмена сообщениями между узлами — какие узлы могут напрямую взаимодействовать при выполнении распределённого алгоритма.

Также имеется множество из n географически распределённых дата-центров, каждый из которых может быть назначен для размещения одного из вычислительных узлов. Эти дата-центры расположены в точках общего положения на карте (никакие три не лежат на одной прямой и никакие два не совпадают).

**Задача:** необходимо сопоставить каждому вычислительному узлу (вершине дерева) уникальный дата-центр (точку на плоскости) так, чтобы если визуализировать каналы связи между узлами как прямые линии между соответствующими дата-центрами, то любые несмежные каналы не пересекались. Это обеспечивает, например, физическую или логическую изоляцию между несвязанными напрямую частями распределённой системы — что важно для устойчивости и безопасности ML-систем.

## Формат ввода

Первая строка содержит одно целое число t — количество тестов.  
1 ≤ t ≤ 1000

Далее для каждого теста:

В первой строке теста содержится одно целое число n — количество узлов (и одновременно точек).  
2 ≤ n, n·t ≤ 1000

Следующие n−1 строк содержат описание рёбер дерева. Каждая строка содержит два целых числа u и v  
(1 ≤ u, v ≤ n) — номера вершин, соединённых ребром. Дерево не содержит циклов и состоит из ровно n−1 ребра.

Далее идут n строк, каждая из которых содержит два действительных числа xᵢ и yᵢ — координаты i-й точки  
на плоскости, в которую можно сопоставить вершину.  
−10⁴ ≤ xᵢ, yᵢ ≤ 10⁴

## Формат вывода

Для каждого теста выведите одну строку из n целых чисел p₁, p₂, …, pₙ — перестановку чисел от 1 до n,  
где pᵢ означает, что вершине i дерева сопоставляется pᵢ-я точка из входного списка.

Таким образом, для каждой вершины дерева выбирается уникальная точка на плоскости, и соединение вершин прямыми отрезками между сопоставленными точками не приводит к пересечению несмежных рёбер.

### Пример 1

| Ввод | Вывод |
|------|--------|
| `1`<br>`2`<br>`1 2`<br>`292.365297 561.624168`<br>`28.742075 869.836531` | `2 1` |
### Пример 2

| Ввод | Вывод |
|------|--------|
| `1`<br>`3`<br>`2 1`<br>`1 3`<br>`38.082299 -593.978441`<br>`-42.281845 -296.136429`<br>`217.814614 -47.946068` | `3 2 1` |

Примечания
Для дебага решений предлагается использовать написанный визуализатор.

```python
import argparse
import matplotlib.pyplot as plt


def read_input_and_output(infile, outfile):
    # Чтение входа
    input_data = list(map(float, infile.read().split()))
    it = iter(input_data)
    t = int(next(it))
    if t != 1:
        raise ValueError("Визуализатор поддерживает только один тест.")
    n = int(next(it))
    edges = [(int(next(it)) - 1, int(next(it)) - 1) for _ in range(n - 1)]
    points = [(next(it), next(it)) for _ in range(n)]

    # Чтение вывода (перестановка)
    perm = list(map(int, outfile.read().split()))
    if len(perm) != n:
        raise ValueError("Размер перестановки не совпадает с числом вершин")

    assigned = [points[p - 1] for p in perm]
    return n, edges, assigned


def visualize(n, edges, assigned, show_ids=False):
    fig, ax = plt.subplots()
    xs, ys = zip(*assigned)
    ax.scatter(xs, ys, color="blue")

    for i, (x, y) in enumerate(assigned):
        if show_ids:
            ax.text(x, y, str(i + 1), fontsize=8, ha="right", va="bottom")

    for u, v in edges:
        x1, y1 = assigned[u]
        x2, y2 = assigned[v]
        ax.plot([x1, x2], [y1, y2], color="black")

    ax.set_aspect("equal")
    ax.set_title("Дерево на плоскости")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()
    plt.show()


def main():
    parser = argparse.ArgumentParser(description="Визуализатор вложенного дерева")
    parser.add_argument(
        "--infile",
        type=argparse.FileType("r"),
        help="Входной файл",
        default="input.txt",
    )
    parser.add_argument(
        "--outfile",
        type=argparse.FileType("r"),
        help="Файл с перестановкой",
        default="output.txt",
    )
    parser.add_argument(
        "--show-ids", action="store_true", help="Показывать номера вершин", default=True
    )
    args, unknown = parser.parse_known_args()

    n, edges, assigned = read_input_and_output(args.infile, args.outfile)
    visualize(n, edges, assigned, args.show_ids)


if __name__ == "__main__":
    main()
```