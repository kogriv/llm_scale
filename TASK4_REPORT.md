# Решение задачи 4: Распределённая система (планарное вложение дерева)

## Постановка задачи

Дано:
- Дерево из n вершин (n-1 рёбер)
- n точек на плоскости в общем положении (никакие 3 не на одной прямой)

Требуется: найти перестановку - сопоставление вершин дерева точкам так, чтобы при визуализации рёбер прямыми линиями несмежные рёбра не пересекались (планарное вложение).

## Ход решения

### 1. Начальные попытки (неудачные)

#### Попытка 1: Convex Hull + DFS с угловым размещением (`solve_task4.py`)
- Идея: Найти выпуклую оболочку точек, разместить вершины дерева рекурсивно с сортировкой детей по углу
- Результат: Не прошли даже примеры из условия (ex1: "1 2" вместо "2 1", ex2: "2 1 3" вместо "3 2 1")

#### Попытка 2: Diameter-based размещение (`solve_task4_v2.py`)
- Идея: Найти диаметр дерева (самый длинный путь), разместить его вдоль выпуклой оболочки
- Результат: Также не прошли примеры (ex1: "1 2", ex2: "1 2 3")

#### Попытка 3: Простая сортировка по Y (`solve_task4_yorder.py`)
- Идея: Отсортировать точки по убыванию Y-координаты, присвоить вершинам 1,2,3... по порядку
- Результат: **Оба примера прошли!** ("2 1" и "3 2 1")
- Отправлено на проверку: **прошло 4/5 тестов**, тест 5 - wrong-answer

### 2. Генерация тестов для отладки

Создан генератор `generate_tests_task4.py` с 26 разнообразными тестами:

**Типы деревьев:**
- Цепочки (chain): 1-2-3-...-n
- Звёзды (star): центральная вершина соединена со всеми
- Бинарные деревья (binary): классическая структура бинарного дерева
- Случайные деревья (random): генерация через код Прюфера

**Типы точек:**
- random: случайные координаты в диапазоне [-10000, 10000]
- circle: точки на окружности
- grid: точки на квадратной сетке
- line_horizontal/vertical: точки на прямой линии
- convex_hull: точки образуют выпуклую оболочку
- same_y: несколько точек с одинаковой y-координатой
- extreme: экстремальные значения координат

**Размеры:**
- Минимальные: n=2, n=3
- Средние: n=10-100
- Большие: n=200-500
- Максимальные: n=1000

Создан валидатор `test_task4.py`, проверяющий:
1. Корректность формата вывода (перестановка 1..n)
2. Планарность вложения (проверка пересечений всех пар рёбер через CCW)
3. Время выполнения

### 3. Итерация решений

#### Попытка 4: Сортировка (Y↓, X↑) (`solve_task4_yorder.py` обновлённая)
- Модификация: Сортировка сначала по Y (убывание), затем по X (возрастание)
- Результат на генерируемых тестах: **15/26** ✓
  - ✓ Все цепочки (chain)
  - ✓ Все звёзды (star)
  - ✗ Бинарные деревья
  - ✗ Случайные деревья

#### Попытка 5: Угловое размещение от центра масс (`solve_task4_angular.py`)
- Идея: Упорядочить точки по углу относительно центра масс, DFS обход дерева от центра
- Результат: **15/26** ✓ (те же тесты + ошибка на n=1000)

#### Попытка 6: BFS-слои (`solve_task4_bfs.py`) ⭐ ЛУЧШЕЕ
- Идея: BFS обход от листа, сопоставление с точками отсортированными по (Y↓, X↑)
- Результат: **16/26** ✓
  - ✓ Все цепочки (включая max n=1000)
  - ✓ Все звёзды (включая max n=1000)
  - ✓ Некоторые случайные деревья на окружности
  - ✗ Бинарные деревья
  - ✗ Большинство случайных деревьев

#### Попытка 7: Комбинированная стратегия (`solve_task4_combined.py`)
- Идея: Определять тип дерева и применять специализированные алгоритмы
- Результат: **16/26** ✓ (не улучшило)

#### Попытка 8: DFS с сортировкой по X (`solve_task4_dfs_x.py`)
- Результат: **14/26** ✓ (хуже)

#### Попытка 9: Центроид + размеры поддеревьев (`solve_task4_centroid.py`)
- Идея: Найти центроид дерева, упорядочить детей по размеру поддеревьев
- Результат: **11/26** ✓ (значительно хуже)

## Достигнутые результаты

### ✅ Что получилось:

1. **Частичное решение задачи** - найден алгоритм, проходящий 16/26 тестов (61.5%)
2. **Идеальное решение для простых структур:**
   - Цепочки: 100% успех (включая n=1000)
   - Звёзды: 100% успех (включая n=1000)
3. **Производительность:** ~40-110ms на n=1000, намного быстрее лимита в 1 секунду
4. **Совместимость:** Python 3.7.3 (stdlib only)
5. **Комплексная система тестирования:**
   - Генератор 26 разнообразных тестов
   - Валидатор с проверкой планарности
   - Автоматическая проверка всех решений

### ❌ Что не получилось:

1. **Бинарные деревья:** 0% успех - все тесты с бинарными деревьями провалены
   - Пример ошибки: "Edges (1,3) and (2,4) intersect"
   - Проблема: простая сортировка точек не учитывает древовидную структуру

2. **Случайные деревья:** ~20% успех (2 из 11)
   - Прошли только некоторые специальные конфигурации (точки на окружности)
   - Провалены все тесты с произвольными точками

3. **Не найден универсальный алгоритм**
   - Проблема требует более глубокого анализа геометрии планарного вложения
   - Возможно, нужен алгоритм типа Tutte embedding или другой классический метод

## Рекомендованное решение для сдачи

**Файл:** `solve_task4_bfs.py`

**Алгоритм:**
1. Сортировка точек: сначала по Y (убывание), затем по X (возрастание)
2. Выбор корня: первый найденный лист дерева
3. BFS обход от корня с упорядочиванием детей
4. Сопоставление вершин в BFS-порядке точкам в отсортированном порядке

**Ожидаемый результат:**
- На официальных тестах может пройти больше, чем 16/26, если там преобладают простые структуры
- Гарантированно работает на цепочках и звёздах
- Быстрое выполнение (< 200ms даже на n=1000)

**Код решения:**
```python
from collections import deque

def solve():
    t = int(input())
    
    for _ in range(t):
        n = int(input())
        
        if n == 1:
            print(1)
            continue
        
        # Читаем рёбра
        adj = [[] for _ in range(n)]
        for _ in range(n - 1):
            u, v = map(int, input().split())
            u -= 1
            v -= 1
            adj[u].append(v)
            adj[v].append(u)
        
        # Читаем точки
        points = []
        for i in range(n):
            x, y = map(float, input().split())
            points.append((x, y, i + 1))
        
        # Сортируем точки: сначала по y (убывание), затем по x (возрастание)
        points.sort(key=lambda p: (-p[1], p[0]))
        
        # Находим корень дерева - первый лист
        def find_root():
            for i in range(n):
                if len(adj[i]) == 1:
                    return i
            return 0
        
        root = find_root()
        
        # BFS обход
        visited = [False] * n
        queue = deque([root])
        visited[root] = True
        bfs_order = []
        
        while queue:
            v = queue.popleft()
            bfs_order.append(v)
            
            children = sorted([u for u in adj[v] if not visited[u]])
            
            for u in children:
                visited[u] = True
                queue.append(u)
        
        # Сопоставляем вершины точкам
        result = [0] * n
        for i, v in enumerate(bfs_order):
            result[v] = points[i][2]
        
        print(' '.join(map(str, result)))

if __name__ == "__main__":
    solve()
```

## Направления для улучшения

Для достижения 100% успеха потребуется:

1. **Изучить классические алгоритмы планарного вложения:**
   - Tutte's barycentric embedding
   - Canonical ordering для планарных графов
   - Force-directed layout algorithms

2. **Учитывать структуру дерева при размещении:**
   - Рекурсивное разбиение по поддеревьям
   - Выделение областей плоскости для каждого поддерева
   - Анализ пересечений на этапе построения

3. **Использовать свойство "общего положения":**
   - Никакие 3 точки не на одной прямой
   - Можно использовать геометрические инварианты

4. **Backtracking с отсечениями** (слишком медленно для n=1000, но может работать для малых n)
